'use strict';

const cheerio = require('cheerio');
const cloudscraper = require('cloudscraper');
const CryptoJS = require("crypto-js");
const request = require('request');

const defaultOptions = {
  baseUrl: 'https://extratorrent.cc',
  timeout: 4 * 1000
};

// taken from http://extratorrent.cc/scripts/main.js		
const CryptoJSAesJson = {
    stringify: function (a) {
        var j = {
            ct: a.ciphertext.toString(CryptoJS.enc.Base64)
        };
        
        if (a.iv) j.iv = a.iv.toString();
        if (a.salt) j.s = a.salt.toString();
        
        return JSON.stringify(j);
    },
    parse: function (a) {
        var j = JSON.parse(a);
        var b = CryptoJS.lib.CipherParams.create({
            ciphertext: CryptoJS.enc.Base64.parse(j.ct)
        });
        
        if (j.iv) b.iv = CryptoJS.enc.Hex.parse(j.iv);
        if (j.s) b.salt = CryptoJS.enc.Hex.parse(j.s);
        
        return b;
    }
};

//Object.assign polyfill
if (typeof Object.assign != 'function') {
  Object.assign = function (target, varArgs) { // .length of function is 2
    'use strict';
    if (target == null) { // TypeError if undefined or null
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
      var nextSource = arguments[index];

      if (nextSource != null) { // Skip over if undefined or null
        for (var nextKey in nextSource) {
          // Avoid bugs when hasOwnProperty is shadowed
          if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
    return to;
  };
}

module.exports = class ExtraTorrentAPI {

  constructor(opts) {
    var options = opts.options;
    var debug = opts.debug;
    var cloudflare = opts.cloudflare;

    ExtraTorrentAPI._options = options || defaultOptions;

    this._cloudflare = (cloudflare === undefined) ? true : cloudflare;

    if(this._cloudflare) {
      this._request = cloudscraper.request;
      this._options = options || defaultOptions;
      if (debug) {
        console.warn('Processing with cloudscraper...');
      }
    } else {
      this._request = request.defaults(options || defaultOptions);
    }

    this._debug = debug || false;

    this._s_cat = {
      "anime": "1",
      "books": "2",
      "games": "3",
      "movies": "4",
      "music": "5",
      "pictures": "6",
      "software": "7",
      "tv": "8",
      "other": "9",
      "mobile": "416",
      "adult": "533"
    };

    this._added = {
      "1": 1,
      "3": 3,
      "7": 7
    };

    this._size_types = {
      "b": "b",
      "kb": "kb",
      "mb": "mb",
      "gb": "gb"
    };
  };

  _get(uri, qs, retry) {
    retry = (retry === undefined) ? true : retry;
    if (this._debug) console.warn(`Making request to: '${uri}'`);
    var _this = this;
    var reqOpts = { uri:uri, qs:qs };
    var p = new Promise(function(resolve, reject) {
      var reReqOpts = reqOpts;
      let options;
      if (_this._cloudflare) {
        options = Object.assign({}, _this._options, {method: 'GET', url: _this._options.baseUrl + reqOpts.uri, qs:reqOpts.qs});
        options.baseUrl = null;
      } else {
        options = { uri:reqOpts.uri, qs:reqOpts.qs };
      }

      _this._request(options, function(err, res, body) {
        if (err && retry) {
          return resolve(_this._get(reReqOpts.uri, reReqOpts.qs, false));
        } else if (err) {
          return reject(err);
        } else if (!body || res.statusCode >= 400) {
          return reject(new Error(`No data found for uri: '${uri}', statuscode: ${res.statusCode}`));
        } else {
          return resolve(body);
        }
      });
    });
    return p;
  };

  _formatPage(res, page, date) {
    //const $ = cheerio.load(res);
    //const total_results = parseInt($("td[style]").text().match(/total\s+(\d+)\s+torrents\s+found/i)[1], 10);

    // et encrypted
    let $ = cheerio.load(res);

    const hashObject = $('div#e_content').text();
    const salt = JSON.parse(hashObject).s;

    const latestNewsId = $('.ten_articles li a').eq(0).attr('href').split('le/')[1].split('/')[0];
    const extraNum = $('.ten_len').length; // might be added dynamically
    //console.warn(salt, latestNewsId, extraNum);
    const key = salt[1] + extraNum + extraNum + '0' + latestNewsId + salt[5];

    const data = JSON.parse(CryptoJS.AES.decrypt(hashObject, key, {
      format: CryptoJSAesJson
    }).toString(CryptoJS.enc.Utf8));

    $ = cheerio.load(data);

    const total_results = parseInt(data.match(/total\s\<b\>(\d+)\<\/b\>\storrents\sfound/i)[1]);
    // /et encrypted

    let total_pages = Math.ceil(total_results / 50);
    if (total_pages > 200) total_pages = 200;

    const result = {
      response_time: parseInt(date, 10),
      page: parseInt(page, 10),
      total_results: parseInt(total_results, 10),
      total_pages: parseInt(total_pages, 10),
      results: []
     };

    $("tr.tlr, tr.tlz").each(function() {
      const entry = $(this).find("td");

      let language, title, sub_category

      const url = ExtraTorrentAPI._options.baseUrl + entry.eq(2).find("a").attr("href");
      const torrent_link = ExtraTorrentAPI._options.baseUrl + entry.eq(0).find("a").eq(0).attr("href");
      const magnet = entry.eq(0).find("a").eq(1).attr("href");
      const date_added = entry.eq(3).text();
      const size = entry.eq(4).text();
      const seeds = ($(this).find("td.sy").text() == '') ? 0 : parseInt($(this).find("td.sy").text(), 10);
      const leechers = ($(this).find("td.ly").text() == '') ? 0 : parseInt($(this).find("td.ly").text(), 10);
      const peers = seeds + leechers;
      const quality = parseInt(entry.last().find("div").attr("class").replace(/r/i, ""), 10);

      let comments = $(this).find("td.tli").find("div#tcmm");
      if (comments.length !== 0) {
        language = entry.eq(2).find("img.icon").eq(1).attr("alt");
        title = entry.eq(2).find("a").eq(1).text();
        sub_category = entry.eq(2).find("a").eq(2).text();
        comments = parseInt(entry.eq(2).find("a").eq(0).text(), 10);
      } else {
        language = entry.eq(2).find("img.icon").eq(0).attr("alt");
        title = entry.eq(2).find("a").eq(0).text();
        sub_category = entry.eq(2).find("a").eq(0).text();
        comments = comments.length;
      };

      result.results.push({ url:url, torrent_link:torrent_link, magnet:magnet, language:language, title:title, sub_category:sub_category, comments:comments, date_added:date_added, size:size, seeds:seeds, leechers:leechers, peers:peers, quality:quality });
    });

    return result;
  };

  _advancedSearch(opts, date) {
    var page = opts.page;
    var with_words = opts.with_words;
    var extact = opts.extact;
    var without = opts.without;
    var category = opts.category;
    var added = opts.added;
    var seeds_from = opts.seeds_from;
    var seeds_to = opts.seeds_to;
    var leechers_from = opts.leechers_from;
    var leechers_to = opts.leechers_to;
    var size_from = opts.size_from;
    var size_to = opts.size_to;
    var size_type = opts.size_type;

    if (!with_words) throw new Error(`'with_words' is a required field`);
    if (added && !this._added[added]) throw new Error(`'${added}' is not a valid value for added!`);
    if (size_type && !this._size_types[size_type]) throw new Error(`'${size_type}' is not a valid value for value size_type!`);

    if (category && !this._s_cat[category]) {
      throw new Error(`${category} is not a valid value for category!`);
    } else if (category && this._s_cat[category]) {
      category = this._s_cat[category];
    }

    var _this = this;
    return this._get("/advanced_search/", {
      page:page,
      "with": with_words,
      extact:extact,
      without:without,
      s_cat: category,
      added:added,
      seeds_from:seeds_from,
      seeds_to:seeds_to,
      leechers_from:leechers_from,
      leechers_to:leechers_to,
      size_from:size_from,
      size_type:size_type,
      size_to:size_to
    }).then(function(res){ return _this._formatPage(res, page, Date.now() - date); });
  };

  _simpleSearch(query, date) {
    var _this = this;
    return this._get("/search/", {search: query}).then(function(res) { return _this._formatPage(res, 1, Date.now() - date) });
  };

  search(query) {
    const t = Date.now();
    if (typeof(query) === "string") {
      return this._simpleSearch(query, t);
    } else if (typeof(query) === "object") {
      return this._advancedSearch(query, t)
    } else {
      throw new Error(`Query needs to be an object or a string!`);
    }
  };

};
